# EthClient

Simple elixir client to interact with the ethereum blockchain, deploying and calling smart contracts.

## Basic usage

### Configuration

All global configuration is kept in the `EthClient.Context` module, which holds the following values:

- `rpc_host`: The hostname needed to interact with the ethereum Json RPC API. This can be an infura-type url or just the hostname of an actual node.
- `chain_id`: The id of the chain currently in use (`1` for mainnet, `4` for Rinkeby, etc).
- `user_account`: A value of type `EthClient.Account`, which holds two fields, `address` and `private_key`. This is the account used to sign and send all transactions.
- `current_contract`: The address of the contract we're currently interacting with.

You can change any of these config values at runtime by using the functions exposed by the `EthClient.Context` module.

The default config assumes you're running the local ethereum network this repo provides.

### Interacting with smart contracts

Currently there are three functions in the `EthClient` module that form the main API:

- `EthClient.deploy(bin_path)`  deploys a compiled smart contract given a path to its `.bin` file, generated by compiling said contract (i.e. by running something like `solc --bin contract.sol`). After a successful deployment, the context will be updated to use it.

- `EthClient.call(method, arguments)` calls any read-only public method of a contract.

- `EthClient.invoke(method, arguments, amount)` calls any public method of a contract that requires a transaction (usually to write stuff to the blockchain). The `amount` parameter controls how much `eth` is sent to the contract.

Currently, both `call` and `invoke` require the user to know the contract's method signatures; this will change soon when we start parsing the ABI of the contract and offer a better API.

## Example

When running `iex -S mix`, there will be a default `bin_path` variable loaded with the path to a compiled `Storage` contract. You can then immediately deploy it with

```
EthClient.deploy(bin_path)
```

and then call each of its functions. If you're running the local ethereum network, you should see something like the following:

```
iex(1)> EthClient.deploy(bin_path)
19:53:26.918 [info]  Deployment transaction accepted by the network, tx_hash: 0x14765466533a85c90ce45dd966854dc5fb95543ba97f343f389872c64ed9597b
19:53:26.922 [info]  Waiting for confirmation...
19:53:28.931 [info]  Contract deployed, address: 0x69148897094941cfad7fd3d52c5e1a810ba4e123 Current contract updated
:ok
```

```
iex(2)> EthClient.call("test_function()", [])
{:ok, "0x0000000000000000000000000000000000000000000000000000000000000001"}
```

```
iex(3)> EthClient.invoke("store(uint256)", [20], 0)
19:55:28.127 [info]  Transaction accepted by the network, tx_hash: 0x137320dcfb61055313f73aafa799670a4d172936bc91200ebf7a95092f77c297
19:55:28.127 [info]  Waiting for confirmation...
19:55:41.177 [info]  Transaction confirmed!
{:ok, "0x137320dcfb61055313f73aafa799670a4d172936bc91200ebf7a95092f77c297"}
```

```
iex(4)> EthClient.call("retrieve()", [])
{:ok, "0x0000000000000000000000000000000000000000000000000000000000000014"}
```
